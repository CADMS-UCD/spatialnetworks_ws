---
title: "Introduction to R"
author: Jose Pablo Gomez-Vazquez
---

____________________________________________________________________

# 1. Basic operations
R is like a calculator, we can make mathematical operations, for example:

```{r}
2 + 2
```

R is a object-oriented programming language, this means that we create objects that contain information. In R you can achieve the same results using different approaches, for example, to create an object we just type a name for the object and assign it a value using the operators `=` or `<-`. We can make operations with objects of the same type, for example:

```{r}
x = 2 # create a new object with the = operator
y <- 2 # create a new object with the <- operator
x + y # make a operation with the objects
```

You can store more than one value using vectors, to create a vector of numbers we use `c()`.
For example, we will store a sequence of numbers from 5 to 10 using 2 different approaches and then ask R if the objects are the same.  
**tip:** using the keys "alt" + "-" will automatically add the operator `<-`. Choosing which assign operator to use is a matter of preference, I personally think that reading code with the operator `<-`, but a lot of people uses `=`.  

```{r}
x <- c(5, 6, 7, 8, 9, 10) # craete a sequence form 5 to 10
y = 5:10 # create the same sequence but with a different approach
x == y # ask R if the objects have the same information
```

When we have a vector, we can ask R specific values inside an object.

```{r}
# Here we ask the 3rd value from our sequence
x[3]
# MNow we multiply the 3rd value of the x sequence times the 5th value of the y sequence
x[3] * y[5]
```

## 1.1 Functions in R

R has a lot of base functions, but we can define new functions. When using R studio, the key *Tab* will help us to auto complete, this can help us a lot when we don't remember the exact name of the functions available.
The best part of programming with R is that it has a very active community. Since its open source, anyone can create functions and compile them in a package (or library). we can download these packages and access new functions.  
Functions in R require arguments, which we can see in the function documentation or if we press the key *Tab* when we are inside the function.  

```{r}
# To get the sum of a vector of numbers inside an object we use sum()
sum(x)
```

We can put functions inside function, for example, to get $\sqrt{\sum_1^n x}$ the square root of a sum of the numbers in x we can use:

```{r}
sqrt(sum(x))
```

Making functions in R is not as complicated as it sounds and can be very useful when we need to do repetitive work. To define a function we need to include the arguments that we want for the function and what are we doing with those areguments. For example, the following function has only one argument which is a name (string) and just pastes some text before and after:

```{r}
F1 <- function(name){
  x <- paste("Hola", name, "! welcome to the R world!") # paste the name with some text
  print(x)
}
# trying the function (Put your name)
F1(name = "Pablo")
```



Besides storing numbers in the objects in R, we can store text, matrices, tables, spatial objects, images, and other types of objects. Next we will import our own data and do some manipulation in R.

____________________________________________________________________

# 2. Importing data into R

R can import data in different formats. The most comon are excel files (*.csv*, *.xls* y *.xlsx*), text files *.txt* and spatial data *.shp*, which we will talk about more in detail later.  
To read *.xls*, *.xlsx* and *.shp* files we will need to install some libraries. To install a new libreary you need to be connected to the internet and use the function `install.packages()` to install the library. Once it has been installed, you can load the library using the function `library()`.  

**Suggestion:** Sometimes when we want to use only one function from a library, we can just write the name of the library followed by the operator `::` and the name of the function, for example: `paquete::funcion()`. This way we won't have to load the whole library.  

```{r}
# If we dont have the library installed, we use:
# install.packages("readxl")
library(readxl) # load the library

# Import the excel file
PRRS <- readxl::read_xlsx("Data/PRRS.xlsx")
```

The most popular format for tables in R are called `data.frame`, when we import the data from a *.csv* o *.xlsx*. We can examine what kind of object it is using the function `class()`, an object can have more than one tpe of class.  

```{r}
class(PRRS)
```

____________________________________________________________________

# 3. Creating tables in R

We can use the base R functions to create basic tables. For example, we can create a table that shows the number of positive by sex:  

```{r}
TBL <- table(PRRS$Sex, PRRS$Result)
TBL
```

When we have a tabe object we can ask for a specific column or row, where is represented as [row, column].  

```{r}
TBL[,2] # Get the second column
```

## 3.1 Data manipulation with dplyr

The library `dplyr` has several functions that can help to clean, create new variables, and modify our data in other ways.  

```{r message = F}
# if we dont have installed the library we will need to install it using:
# install.packages("dplyr")
# we load the library:
library(dplyr)
```

`dplyr` introduces a new operator called pipes `%>%`, which can connect several functions to an object. This is an alternative to write several functions in a single "line of code" in a more organized way. For example:  

**F2(F1(x)) is the same as x %>% F1() %>% F2()**  

**Suggestion:** we can use the keys *Ctrl* + *shift* + *m* to insert the `%>%` operator.  

We will use this concepts to calculate the prevalence by county:  

```{r}
PRRS %>% 
  group_by(County) %>% 
  summarise(N = n(), positive = sum(Result)) %>% 
  mutate(Prev = positive/N) %>% 
  arrange(desc(Prev))
```

Ok, so we used several functions connected to calculate the prevalence, so I will explain it by parts:  
  
  - First we put the name of our data.  
  - The first function `group_by()` will group the observations by one or more variables that we indicate.   
  - The function `summarise()` will execute a function we define for a variable from the defined grouping variable, e.g. when we write `n()` returns the number of observations per group and with `sum(resultado)` we are summing all the positive results by each county.    
  - The function `mutate()` will create a new variable, we use the variables *N* and *positive* created wuth the previous functions  and calculating the prevalence.  


**Exercise:** Now try to calculate the prevalence by farm type (variable *farm_type*):

```{r}
# Answer
```

We can use any function with summarize, this is very useful because it allows to obtain quick statistics stratified by groups, for example, we can obtain the median, mean and variance by age and sex:  

```{r}
PRRS %>% 
  group_by(Sex) %>% 
  summarise(media_edad = mean(Age), mediana_edad = median(Age), SD_edad = sd(Age))
```


## 3.2 Joining datasets:


```{r}
# Importing the farm dataseet
nodes <- read.csv("Data/node_attrib.csv")
# Importing the movement dataset
mov <- read.csv("Data/network.csv")
# Get the number of outgoing and incoming shipments 
Out <- mov %>% 
  group_by(id_orig) %>%
  summarise(Envios = n()) %>%
  rename(id = id_orig)
In <- mov %>%
  group_by(id_dest) %>%
  summarise(Arribos = n()) %>% 
  rename(id = id_dest)

# Joining the two datasets
nodes <- nodes %>% 
  left_join(Out, by ="id")
nodes <- nodes %>%
  left_join(In, by = "id")
```

Now we will get the ones that had the higher number of movements: 

```{r}
mov %>% 
  group_by(id_orig) %>% 
  summarise(N = n(), NUm.Cerdos = sum(pigs.moved)) %>%
  arrange(desc(N)) %>%
  head()
```
  
____________________________________________________________________
  
  
# 4. Creating figures with R

The base R package includes several tools to create different type of plots. There are packages that adds more specific functions (such as `ggplot2`).

## Scatterplot

One of the most basic type of plots are the scatterplot, these are useful when we want to see the relationship between two continuous variables. To do this we can 

```{r}
plot(Envios~Arribos, data = nodes)

plot(nodes$Envios, nodes$Arribos)
```


## 4.1 Grafico de pay

Los graficos de pay nos sirven para mostrar proporciones, por ejemplo a continuacion haremos un grafico que represente los porcentajes de animales positivos por tipo de granja.  
Para seleccionar una variable dentro de una data.frame, utilizamos el caracter `$`, por ejemplo, si queremos accesar a la variable tipo de granja (farm_type) de la tabla PRRS, usamos `PRRS$farm_type`
```{r}
# Primero creamos una tabla para el resultado por sexo del animal
TM <- table(PRRS$farm_type, PRRS$Result)
# Despues usaremos la segunda columna de nuestra tabla, que contiene los positivos unicamente
pie(TM[,2])
```

## 4.2 Boxplots  
En mi opinion los boxplots son los graficos mas utiles para ver la distribucion de una variable continua. Como todas las funciones en R, la funcion `boxplot()` tiene varios argumentos que podemos proporcionar, pero si solo le proporcionamis el nombre de una variable continua, nos regresara un boxplot un poco aburrido de la variable  
```{r}
boxplot(x = PRRS$Age)
```

Podemos poporcionar differentes argumentos para mejorar nuestra grafica, asi como estratificar nuestra variable por otra variable categorica:  
```{r}
boxplot(Age~Sex, data = PRRS, col = "lightgreen", 
        main = "Grafico de caja de la edad estratificado por sexo")
```

Las funciones de base para graficos de R son muy flexibles, mientras mas las utilices mas te daras cuenta de todos los argumentos que tienen para ayudarte a hacer graficos mas informativos y personalizables, la mayoria de los argumentos son intuitivos, pero puedes ver que hace cada uno en la documentacion de la funcion o en la opcion de autocompletar. 



## 4.3 Graficos de barras

Para el siguiente grafico utilizaremos mas argumentos, vamos a estratificar el resultado por el sexo del animal:
```{r }
# Primero creamos una tabla de los resultados por tipo de granja
TM <- table(PRRS$Result, PRRS$Sex)
# Despues usaremos la duncion par() para incrementar los margenes:
par(mar = c(2, 6, 2, 2))
barplot(TM[, order(colSums(TM), decreasing = T)], beside = T, horiz = T, 
        las = 2, main = "Resultados por tipo de granja", col = c("green", "red"), 
        legend = rownames(TM))
```

**Ejercicio:** Haz un grafico de barras estratificando el resultado por el tipo de granja:

```{r}
# Primero creamos una tabla de los resultados por tipo de granja
TM <- table(PRRS$Result, PRRS$farm_type)
# Despues usaremos la duncion par() para incrementar los margenes:
par(mar = c(2, 6, 2, 2))
barplot(TM[, order(colSums(TM), decreasing = T)], beside = T, horiz = T, 
        las = 2, main = "Resultados por tipo de granja", col = c("green", "red"), 
        legend = rownames(TM))
```


## 4.4 Graficos temporales.

Para hacer un grafico temporal primero tenemos que manipular un poco las fechas para que R pueda reconocerlas y despues veremos el numero de movimientos por semana
```{r}
mov$date <- as.Date(mov$date, "%m/%d/%y")
# Creamos una variable para identificar la semana del año
mov$week <- format(mov$date, "%V")
```

```{r}
mw <- mov %>% 
  group_by(week) %>% 
  summarise(N = n())

plot(N~week, data = mw, type = "l", col = "darkgreen", main = "Movimientos por semana", xlab = "Semana del año", ylab = "Numero de movimientos")
```

[Regresar](Temario_WS02.html)

