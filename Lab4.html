<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Lab 4</title>

<script src="site_libs/header-attrs-2.13/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">CADMS</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Pre Workshop
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Intro_to_R.html">Intro to R</a>
    </li>
    <li>
      <a href="Spatial_intro.html">Intro to Spatial data</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Contact
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Instructors.html">
        <span class="fa fa-users"></span>
         
        Instructors
      </a>
    </li>
    <li>
      <a href="https://cadms.vetmed.ucdavis.edu">
        <span class="fa fa-server"></span>
         
        CADMS Website
      </a>
    </li>
    <li>
      <a href="mailto:jpgo@ucdavis.edu">
        <span class="fa fa-envelope"></span>
         
        Email
      </a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Lab 4</h1>

</div>


<p>Let’s start by importing the data for edges, node attributes, and the shapefile of the area of study.</p>
<pre class="r"><code>colpal &lt;- RColorBrewer::brewer.pal(4, &quot;Dark2&quot;)

library(dplyr)
library(sf)
library(tidygraph)
# Load data of movements and nodes 
net &lt;- STNet::SwineMov
node_attrib &lt;- STNet::SwinePrem %&gt;% 
  mutate(idch = as.character(id)) # Format id as character to use it later
# Load the spatial object
IO &lt;- st_read(system.file(&quot;data/Io.shp&quot;, package = &quot;STNet&quot;), quiet = T)</code></pre>
<div id="introduction-to-dynamic-networks" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Introduction to dynamic networks</h1>
<p>The <code>networkDynamic</code> package has functions that allow to analyze and visualize a network and incorporate temporality to it. To incorporate a temporal window, we need to specify the start time (onset) and end time (termini). For the purposes of this example we will assume that the contact time is one week.</p>
<pre class="r"><code># Load libraries
## For dynamic networks
library(networkDynamic)
# To visualize and get network statistics
library(ndtv)
library(tsna)

net &lt;- net %&gt;%
  mutate(date = as.Date(date, format = &#39;%m/%d/%y&#39;), # Format the variable as date:
         year = as.numeric(strftime(date,format = &quot;%Y&quot;)), # Create a new variable for year from the date
         w = as.numeric(strftime(date,format = &quot;%V&quot;))) # Create a new variable to show the week of the year</code></pre>
<p>In this analysis we will use a one week resolution. Since we have no information on the duration of the contact, we will assume that the duration is one week. As we have multiple years, we need to number the weeks from the first week in which we have data to the last week with data. For this, we will use an offset that will add 53 weeks or 106 depending on the year.</p>
<pre class="r"><code># Create the onset starting from 2015, 
# Use ifelse inside another ifelse to determinate the offset
net$w_onset&lt;-as.numeric(ifelse(net$year==2015 #First condition
                               ,net$w # If the condition is true, only the number of week, if not, we use other ifelse 
                               ,ifelse(net$year==2016 # Second condition
                                       ,net$w+53 # If the condition is true, an offset of 53 weeks is added, 106 weeks otherwise
                                       ,net$w+106)))

# Now we state that the duration of the contact is one week 
net$w_termini&lt;-net$w_onset+1</code></pre>
<p>Now we will create a dynamic network with this information. The <code>networkDynamic</code> function is able to reproduce the data in different formats. Here we will use a <code>data.frame</code> format. The function will read the data and will expect a list of variables following this order: <code>head</code>, <code>tail</code>, <code>onset</code> and <code>termini</code>, where: <code>head</code> = Origins. <code>tail</code> = Destination. <code>onset</code> = Start of contact. <code>termini</code> = End of contact.</p>
<pre class="r"><code>n1 &lt;- networkDynamic(edge.spells = net[c(&quot;w_onset&quot;, &quot;w_termini&quot;, &quot;id_dest&quot;, &quot;id_orig&quot;)])</code></pre>
<pre><code>## Initializing base.net of size 40 imputed from maximum vertex id in edge records
## Created net.obs.period to describe network
##  Network observation period info:
##   Number of observation spells: 1 
##   Maximal time range observed: 31 until 93 
##   Temporal mode: continuous 
##   Time unit: unknown 
##   Suggested time increment: NA</code></pre>
<p>Now we can add attributes to the data. These attributes can be static or change during the period. <strong>Note:</strong> the functions <code>set.edge.attribute()</code> and <code>set.vertex.attribute()</code> from the package network can be masked by other functions with the same name that are present in other packages, such as the <code>igraph</code> package. If we have already loaded these other packages with functions in conflict, we will need to specify which package contains the function that we want to use to prevent wrong calls (i.e. by typing <code>network::set.edge.attribute()</code>).</p>
<pre class="r"><code>set.edge.attribute(n1, #Name of the network
                   &quot;pigs.moved&quot;,  # Name of the attribute
                   net$pigs.moved) # Values</code></pre>
<p>We can then just add the unchanging vertex attribute data</p>
<pre class="r"><code>set.vertex.attribute(n1,&quot;name&quot;, as.character(node_attrib$name))
set.vertex.attribute(n1,&quot;lat&quot;,node_attrib$lat)
set.vertex.attribute(n1,&quot;long&quot;,node_attrib$long)
set.vertex.attribute(n1,&quot;type&quot;,as.character(node_attrib$farm_type))</code></pre>
<p>Once we have the node attributes, we can print them by calling the <code>networkDynamic</code> object that we have just created</p>
<pre class="r"><code>n1</code></pre>
<pre><code>## NetworkDynamic properties:
##   distinct change times: 51 
##   maximal time range: 31 until  93 
## 
## Includes optional net.obs.period attribute:
##  Network observation period info:
##   Number of observation spells: 1 
##   Maximal time range observed: 31 until 93 
##   Temporal mode: continuous 
##   Time unit: unknown 
##   Suggested time increment: NA 
## 
##  Network attributes:
##   vertices = 40 
##   directed = TRUE 
##   hyper = FALSE 
##   loops = FALSE 
##   multiple = FALSE 
##   bipartite = FALSE 
##   net.obs.period: (not shown)
##   total edges= 86 
##     missing edges= 0 
##     non-missing edges= 86 
## 
##  Vertex attribute names: 
##     lat long name type vertex.names 
## 
##  Edge attribute names: 
##     active pigs.moved</code></pre>
<p>This object summarizes the network including the period and number of vertices and edges</p>
<pre class="r"><code>list.edge.attributes(n1)</code></pre>
<pre><code>## [1] &quot;active&quot;     &quot;na&quot;         &quot;pigs.moved&quot;</code></pre>
<pre class="r"><code>list.vertex.attributes(n1)</code></pre>
<pre><code>## [1] &quot;lat&quot;          &quot;long&quot;         &quot;na&quot;           &quot;name&quot;         &quot;type&quot;        
## [6] &quot;vertex.names&quot;</code></pre>
<p>If we want to see the values of these attributes, we can use <code>get.vertex.attribute()</code>:</p>
<pre class="r"><code>get.vertex.attribute(n1, &quot;vertex.names&quot;)</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40</code></pre>
<pre class="r"><code>get.vertex.attribute(n1,&quot;type&quot;)</code></pre>
<pre><code>##  [1] &quot;sow farm&quot;  &quot;sow farm&quot;  &quot;nursery&quot;   &quot;sow farm&quot;  &quot;GDU&quot;       &quot;GDU&quot;      
##  [7] &quot;GDU&quot;       &quot;sow farm&quot;  &quot;nursery&quot;   &quot;nursery&quot;   &quot;nursery&quot;   &quot;nursery&quot;  
## [13] &quot;nursery&quot;   &quot;nursery&quot;   &quot;finisher&quot;  &quot;finisher&quot;  &quot;finisher&quot;  &quot;finisher&quot; 
## [19] &quot;sow farm&quot;  &quot;finisher&quot;  &quot;nursery&quot;   &quot;sow farm&quot;  &quot;sow farm&quot;  &quot;sow farm&quot; 
## [25] &quot;GDU&quot;       &quot;sow farm&quot;  &quot;nursery&quot;   &quot;nursery&quot;   &quot;nursery&quot;   &quot;nursery&quot;  
## [31] &quot;GDU&quot;       &quot;boar stud&quot; &quot;sow farm&quot;  &quot;sow farm&quot;  &quot;sow farm&quot;  &quot;sow farm&quot; 
## [37] &quot;sow farm&quot;  &quot;sow farm&quot;  &quot;sow farm&quot;  &quot;sow farm&quot;</code></pre>
<p>We can also obtain more information of the network, such as the activity by using <code>get.vertex.activity()</code> or <code>get.edge.activity()</code></p>
<pre class="r"><code>summary(get.vertex.activity(n1, as.spellList=TRUE))</code></pre>
<pre><code>##      onset       terminus    vertex.id     onset.censored terminus.censored
##  Min.   :31   Min.   :93   Min.   : 1.00   Mode:logical   Mode:logical     
##  1st Qu.:31   1st Qu.:93   1st Qu.:10.75   TRUE:40        TRUE:40          
##  Median :31   Median :93   Median :20.50                                   
##  Mean   :31   Mean   :93   Mean   :20.50                                   
##  3rd Qu.:31   3rd Qu.:93   3rd Qu.:30.25                                   
##  Max.   :31   Max.   :93   Max.   :40.00                                   
##     duration 
##  Min.   :62  
##  1st Qu.:62  
##  Median :62  
##  Mean   :62  
##  3rd Qu.:62  
##  Max.   :62</code></pre>
<pre class="r"><code>summary(get.edge.activity(n1, as.spellList=TRUE))</code></pre>
<pre><code>##      onset          terminus          tail            head      
##  Min.   :31.00   Min.   :33.00   Min.   : 1.00   Min.   : 1.00  
##  1st Qu.:38.00   1st Qu.:39.00   1st Qu.: 6.00   1st Qu.: 9.75  
##  Median :46.00   Median :48.00   Median :10.00   Median :20.00  
##  Mean   :48.98   Mean   :50.57   Mean   :12.25   Mean   :18.33  
##  3rd Qu.:58.00   3rd Qu.:59.00   3rd Qu.:17.00   3rd Qu.:25.00  
##  Max.   :91.00   Max.   :93.00   Max.   :36.00   Max.   :40.00  
##  onset.censored  terminus.censored    duration       edge.id     
##  Mode :logical   Mode :logical     Min.   :1.00   Min.   : 1.00  
##  FALSE:144       FALSE:144         1st Qu.:1.00   1st Qu.:15.75  
##                                    Median :1.00   Median :40.50  
##                                    Mean   :1.59   Mean   :39.76  
##                                    3rd Qu.:2.00   3rd Qu.:60.25  
##                                    Max.   :9.00   Max.   :86.00</code></pre>
</div>
<div id="temporal-statistics" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Temporal statistics</h1>
<p>We can evaluate several measures at the graph level, vertex level or traces of the period of study of our network using the function <code>tSnaStats()</code>.</p>
<p>This function uses arguments to include the <code>networkDynamic</code> object that we have created and to specify the function with the desired statistic that we want to apply (through the argument “snafun=”). For example, if we want to calculate the density of the network in different periods, we will do this:</p>
<pre class="r"><code>tSnaStats(n1, snafun = &quot;gden&quot;) %&gt;% # &quot;gden&quot; to show graph density
  plot(col = colpal[2], lwd = 2, main = &quot;Network density during the study period&quot;)</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>In the previous plot we can see that the activity of movements is bigger at the beginning of the time series and slowly decreases over time until reaching approximately zero.</p>
<p>The function <code>tSnaStats()</code> also allows us to use arguments to define specific periods of time from which we want to calculate the statistics</p>
<pre class="r"><code>tSnaStats(n1, snafun = &quot;grecip&quot;, start = 30, end = 60) %&gt;% 
  plot(main = &quot;Network Reciprocity during the interval 30-60&quot;, col = colpal[3], lwd = 2)</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>We can also see node-level statistics (e.g. betweenness) using the next function.</p>
<pre class="r"><code>apply(tSnaStats(n1, snafun = &quot;betweenness&quot;), 1, mean) %&gt;% 
  plot(type = &quot;l&quot;, lwd = 2, col = colpal[4])</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
</div>
<div id="plotting-the-network" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Plotting the network</h1>
<p>We can use the function <code>plot()</code> to see the network object, but we can only see the static network because we are not defining any time interval</p>
<pre class="r"><code>plot(n1,mode=&quot;kamadakawai&quot;) </code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>If we want to see a specific period of time, we need to define it. For this, we can use the function <code>network.extract()</code> to extract a specific period in the network and then use <code>plot()</code> to show this extract.</p>
<pre class="r"><code># Plot an interval of time
n1 %&gt;% 
  network.extract(onset = 1, terminus = 60) %&gt;%
  plot()</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<pre class="r"><code># Plot a specific timepoint and remove isolates
n1 %&gt;% 
  network.extract(at = 35) %&gt;%
  plot(displayisolates = F)</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>Now we are going to create a plot with multiple periods of time</p>
<pre class="r"><code># First we create a function to plot the network extract we want:
plot.extract &lt;- function(n, onset, terminus){
  n %&gt;% # The input network
    network.extract(onset = onset, terminus = terminus) %&gt;% #Extract the time interval
    plot(vertex.cex = 1.5, main = paste0(&quot;t&quot;, onset, &quot;-&quot;, &quot;t&quot;, terminus)) #Plot the network
}

# Then we define out time intervals
O &lt;- seq(from = 25, to = 95, by = 10)
# We set the layout we want for the plot:
par(mfrow = c(2,4), mar = c(0,0,1,0))
# We use a for loop to plot the network at the defined time intervals.
for(i in O){
  plot.extract(n1, onset = i, terminus = i + 10)
}</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>We can use different layouts to plot the extracts of the network. Now, we are going to plot the nodes in their spatial location. For this, we will have to make a little modification of our previous function so we can add the coordinates.</p>
<pre class="r"><code># We set fixed coordinates from the longitude and latitude
a &lt;- as.matrix(node_attrib[, c(&quot;long&quot;, &quot;lat&quot;)])


# Modify the function:
plot.extract &lt;- function(n, onset, terminus, Bg){
  plot(Bg, col = &quot;grey90&quot;, lwd = 0.3, main = paste0(&quot;t&quot;, onset, &quot;-&quot;, &quot;t&quot;, terminus))
  n %&gt;% # The input network
    network.extract(onset = onset, terminus = terminus) %&gt;% #Extract the time interval
    plot(vertex.cex = 1, coord=as.matrix(a), new = F) #Plot the network
}


# We set the layout we want for the plot:
par(mfrow = c(2,4), mar = c(0,0,1,0))
# We use a foor loop to plot the network at the defined time intervals.
for(i in O){
  plot.extract(n1, onset = i, terminus = i + 10, Bg = IO$geometry)
}</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
</div>
<div id="temporally-reachable-sets" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Temporally reachable sets</h1>
<p>The reachability of a farm help us to identify important nodes in the network that may have a key role in the disease spread. Forward reachability (“fwd”) refers to all the nodes than can be reached from a given node <span class="math inline">\(v_i\)</span> and backward reachability (“bkwd”) refers to those nodes that reach a given node <span class="math inline">\(v_i\)</span>. We can visualize the distribution of the forward and backward reachability using boxplots</p>
<pre class="r"><code>fwd &lt;- tReach(n1, &quot;fwd&quot;)
bwd &lt;- tReach(n1, &quot;bkwd&quot;)
par(mar=c(2,4,2,2))
boxplot(fwd, bwd, col = &quot;lightgreen&quot;, horizontal = T, yaxt = &#39;n&#39;, main = &quot;Reachability of farms&quot;)
axis(2, at = c(1,2), labels = c(&quot;Fwd&quot;, &quot;Bwd&quot;), las=2, lty = 0)</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<p>We can also use a dot plot to explore whether any interesting relationship between both types of reachability exists.</p>
<pre class="r"><code>plot(fwd, bwd, xlab = &quot;Fwd&quot;, ylab = &quot;Bwd&quot;, pch = 16, col = rgb(0, 155, 50, max=255, alpha=100))</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<p>Now, let’s have a look at the farms with the highest forward reachability:</p>
<pre class="r"><code>data.frame(id = 1:length(fwd), fwd, bwd) %&gt;% 
  arrange(desc(fwd)) %&gt;% 
  head(10)</code></pre>
<pre><code>##    id fwd bwd
## 1   7  24   2
## 2   8  22   6
## 3  17  22  15
## 4   4  21  12
## 5  14  21  12
## 6  12  16   7
## 7  22  14   1
## 8   1  13  12
## 9  19  13  15
## 10 26  13   1</code></pre>
<p>It looks like node (“id”) 7 presents the highest number of reachable farms.</p>
<p>We can visualize the reachable set using the functions <code>tpath</code> and <code>transmissionTimeline</code>. Both of them provide the node id and the time when the contact happened. The first function allow us to visualize the nodes spatially and the second one shows them in a nice timeline. Let’s start with the first one.</p>
<pre class="r"><code>P17 &lt;- tPath(n1, 17, direction = &quot;fwd&quot;)
plot(P17)</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>We can also visualize the paths in the full network.</p>
<pre class="r"><code>plotPaths(n1, P17, vertex.col = colpal[1], label.cex = 0.5, vertex.cex = 2)</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<p>A better way to visualize the paths trough the time period is using the function <code>transmissionTimeline()</code>. In this visualization, the x axis represents the time when the event happened and the y axis represents the generation or steps that happened to reach that node</p>
<pre class="r"><code>transmissionTimeline(P17,jitter=T,
          main=&#39;Earliest forward path from vertex 17&#39;)</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<p>We can also see the backward reachability, which represents the set of nodes that reach a specific node over a time period.</p>
<pre class="r"><code>P17 &lt;- tPath(n1, 17, direction = &quot;bkwd&quot;, type = &quot;latest.depart&quot;)
plot(P17, edge.col = colpal[3])</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
<p>Now we will create a function to show the paths in a spatial and non-spatial plot.</p>
<pre class="r"><code>MaPaths &lt;- function(Net, v, direction, Pts, coords, BG){
  # Settings for the visualization arrangement:
  par(mfrow = c(1,2), oma = c(0, 0, 2, 0), mar = c(1, 1, 1, 1))
  # Geth the path for the node we want
  P1 &lt;- tPath(Net, v = v, direction = direction)
  # Plot the map that will be used for background
  plot(BG, col = &quot;grey90&quot;, lwd = 0.3, axes = F)
  # add the farm locations:
  points(Pts[, c(&quot;long&quot;, &quot;lat&quot;)], pch = 16, cex = 0.5, col = rgb(0, 150, 100, max = 255, alpha = 50))
  # add the edges to the map
  plot(P1, coord = coords, displaylabels = F, edge.label.col = rgb(0,0,0,0), edge.lwd = 2, vertex.col = &quot;white&quot;, edge.col = rgb(0, 200, 50, max=255, alpha=166), new = F)
  
  # add the edges on the side for a non-spatial visualization
  plot(P1, displaylabels = F,edge.lwd = 2, vertex.col = &quot;white&quot;, edge.col = rgb(255, 0, 50, max=255, alpha=166))
  # add the text
  mtext(paste0(&quot;Reachable set of farm&quot;, v), outer = TRUE, cex = 1.5)
}

MaPaths(Net = n1, v = 17, direction = &quot;fwd&quot;, Pts = node_attrib, coords = a, BG = IO$geometry)</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<p>Another way to visualize the network activity is to show the time points when each of the nodes was active. In the following plot, the upper part represents the presence of the node in the network and the lower part represents the activity of the node in the network.</p>
<pre class="r"><code>timeline(n1)</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
</div>
<div id="animations" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Animations</h1>
<p>We can also create animations to show the evolution of the contact patterns over time using the function <code>render.d3movie()</code>. First we will use the function <code>compute.animation()</code> to set the layout and time frame for the animation.</p>
<pre class="r"><code>render.d3movie(n1,
               displaylabels=F, 
               launchBrowser = T, 
               vertex.cex = scales::rescale(degree(n1), to = c(1, 5)), filename = &quot;Animation01.html&quot;) </code></pre>
<p>If we would like to take specific frames for the animation, we can show them stacked in a plot using the function <code>timePrism()</code>. This visualization method works better for small networks.</p>
<pre class="r"><code># Define the intervals
compute.animation(n1, animation.mode = &quot;kamadakawai&quot;,
                  slice.par=list(start=30, end=100, interval=1, 
                         aggregate.dur=1, rule=&#39;any&#39;))

timePrism(n1, at = c(30, 40, 50, 60), planes = T)</code></pre>
<p><img src="Lab4_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
<hr />
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
